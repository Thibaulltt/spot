#ifndef SPOT__GLM_BRIDGE_HPP_
#define SPOT__GLM_BRIDGE_HPP_

/*=============================================
 * Creator     : thib
 * Created on  : 26/08/22
 * Path        : /glm_bridge.hpp
 * Description : Provides a GLM include, and utility functions to interact with the current code base.
 *=============================================
 */

#define GLM_FORCE_RADIANS
#include <glm/glm.hpp>
#include <fmt/format.h>

#include <chrono>
#include <random>

namespace glm {

	/// @brief Provides a random vector creation utility.
	/// @returns A random vector, with coordinates sampled between 0 and 1, in the data type chosen.
	template <length_t length, typename data_type, qualifier precision>
	glm::vec<length, data_type, precision> random() {
		// Get random value generator, seeded from current time :
		std::default_random_engine random_engine(std::chrono::steady_clock::now().time_since_epoch().count());
		std::uniform_real_distribution<data_type> distribution(data_type(0), data_type(1));

		glm::vec<length, data_type, precision> out_value{};
		for (length_t component = 0; component < length; ++component) {
			out_value[component] = distribution(random_engine);
		}
		return out_value;
	}

	/// @brief Shortcut to not have to specify the template parameters when calling random.
	/// @details This call will return a random vector as generated by glm::random<>(), but thanks to the template deduction system of C++, it'll use the
	/// argument's template parameters as the glm::random<>() parameters.
	/// @returns A random vector of the same type as the one in argument.
	template <length_t length, typename data_type, qualifier precision>
	glm::vec<length, data_type, precision> random(const glm::vec<length, data_type, precision>& typeinfo) {
		return random<length, data_type, precision>();
	}

}

#endif //SPOT__GLM_BRIDGE_HPP_
